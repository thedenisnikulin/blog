<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Type-level Bubble Sort in Rust: Part 2 | tinyblog</title>
<meta name="keywords" content="">
<meta name="description" content="Hello everyone! In the previous post from this series we discussed traits, type-level number representation, and implementation of basic type-level computations. The topic of this article is type-level lists. Make some tea or coffee and let&rsquo;s dive into the details!
Image source: link
Type-level lists There&rsquo;s a data structure that you are most probably familiar with - a linked list. Each element of a linked list stores a value and points to the next element, and the last element of such list points to nothing.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/type-level-bubble-sort-2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/type-level-bubble-sort-2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="tinyblog (Alt + H)">tinyblog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Type-level Bubble Sort in Rust: Part 2
    </h1>
    <div class="post-meta"><span title='2022-03-16 22:42:08 +0300 MSK'>March 16, 2022</span>&nbsp;繚&nbsp;9 min

</div>
  </header> 
  <div class="post-content"><p>Hello everyone! In the <a href="https://dev.to/thedenisnikulin/type-level-bubble-sort-in-rust-part-1-3mcb">previous post from this series</a> we discussed traits, type-level number representation, and implementation of basic type-level computations. The topic of this article is type-level lists. Make some tea or coffee and let&rsquo;s dive into the details!</p>
<p><img loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/cfu16rhpxitb5hlza9tv.jpeg" alt="Rust-chan UwU"  />
 Image source: <a href="https://twitter.com/maiRandomness/status/1011951419228852224?s=20&amp;t=X-E0v8wIzSATDxXeNEmZZQ">link</a></p>
<h2 id="type-level-lists">Type-level lists<a hidden class="anchor" aria-hidden="true" href="#type-level-lists">#</a></h2>
<p>There&rsquo;s a data structure that you are most probably familiar with - a linked list. Each element of a linked list stores a value and points to the next element, and the last element of such list points to nothing. This data structure is easily represented with <strong>recursion</strong>, where the &ldquo;nothing&rdquo; is the base case, and an &ldquo;element&rdquo; is the recursive case. We actually will work with recursion quite a lot (the comparison of type-level numbers was also based on recursion), so you may need to learn to understand it.</p>
<p>The way we can define the list in Rust:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Nil</span>; <span style="color:#75715e">// a &#34;null&#34; ref
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Cons</span><span style="color:#f92672">&lt;</span>H, T<span style="color:#f92672">&gt;</span>(H, T); <span style="color:#75715e">// value and a ref to next element
</span></span></span></code></pre></div><p>The way we can use it in Rust:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>Cons<span style="color:#f92672">&lt;</span>Succ<span style="color:#f92672">&lt;</span>Zero<span style="color:#f92672">&gt;</span>, Cons<span style="color:#f92672">&lt;</span>Zero, Cons<span style="color:#f92672">&lt;</span>Zero, Nil<span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#75715e">// a typical type-level list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Cons<span style="color:#f92672">&lt;</span>Zero, Nil<span style="color:#f92672">&gt;</span> <span style="color:#75715e">// smol type-level list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Nil <span style="color:#75715e">// the smolest of them all
</span></span></span></code></pre></div><p>The above examples are the same thing as <code>[1, 0, 0]</code>, <code>[0]</code>, and <code>[]</code> respectively on the value level.
The names <code>cons</code> and <code>nil</code> are terms from functional programming, but don&rsquo;t let them confuse you, it&rsquo;s just a fancy way of saying things (<a href="https://en.wikipedia.org/wiki/Cons">wikipedia page</a> if you&rsquo;re curious). Also, the type parameters are named after terms <code>head</code> and <code>tail</code>.</p>
<h2 id="defining-basic-computations">Defining basic computations<a hidden class="anchor" aria-hidden="true" href="#defining-basic-computations">#</a></h2>
<p>When implementing bubble sort, we will need a lot of helper &ldquo;functions&rdquo; for things like concatenation, swapping, and some others operations on list&rsquo;s elements. Let&rsquo;s define a trait that will represent an operation for <code>prepend</code>ing a number to a list.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// the naming &#34;ComputeX&#34; is used only for convenience,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// we will have a type alias named simply &#34;Prepend&#34; later on.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">trait</span> ComputePrepend<span style="color:#f92672">&lt;</span>N<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The number <code>N</code> will be prepended to the list for which this trait will be implemented.</p>
<p>The implementations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>N<span style="color:#f92672">&gt;</span> ComputePrepend<span style="color:#f92672">&lt;</span>N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Nil {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Cons<span style="color:#f92672">&lt;</span>N, Nil<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is quite simple: we prepend arbitrary <code>N</code> to <code>Nil</code> and that results in <code>Cons&lt;N, Nil&gt;</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>N, H, T<span style="color:#f92672">&gt;</span> ComputePrepend<span style="color:#f92672">&lt;</span>N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Cons<span style="color:#f92672">&lt;</span>H, T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Cons<span style="color:#f92672">&lt;</span>N, Cons<span style="color:#f92672">&lt;</span>H, T<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we prepend <code>N</code> to <code>Cons&lt;H, T&gt;</code>. This also seems not so hard to get.</p>
<p>Let&rsquo;s define the type alias:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Prepend</span><span style="color:#f92672">&lt;</span>N, L<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>L <span style="color:#66d9ef">as</span> ComputePrepend<span style="color:#f92672">&lt;</span>N<span style="color:#f92672">&gt;&gt;</span>::Output;
</span></span></code></pre></div><p>and test it:
<img loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gnwjft9wgkix90yky87z.png" alt="prepending demo"  />
</p>
<p>The compiler inferred <code>Cons&lt;Zero, Cons&lt;Succ&lt;Zero&gt;, Nil&gt;&gt;</code> for us, great! Now we have a basic understanding of numbers, lists, and trait multidispatching. We can use it to write the rest of helper traits for our bubble sort algorithm. But first, let&rsquo;s define the algorithm itself.</p>
<h2 id="recursive-bubble-sort-algorithm">Recursive bubble sort algorithm<a hidden class="anchor" aria-hidden="true" href="#recursive-bubble-sort-algorithm">#</a></h2>
<p>Here&rsquo;s the implementation of value-level bubble sort algorithm in pseudo-code with heavy usage of recursion.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">bubble_sort</span>(arr)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (arr.len() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> arr
</span></span><span style="display:flex;"><span>    bubbled <span style="color:#f92672">=</span> bubble(arr)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> prepend(bubbled.head, bubble_sort(bubbled.tail));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">bubble</span>(arr)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (arr.len() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> arr
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> prepend(arr.head, swapIfLess(arr.head, bubble(arr.tail)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">swapIfLess</span>(head, tail) -&gt; <span style="color:#a6e22e">arr</span> <span style="color:#75715e">// swap tail[0] with head if tail[0] &lt; head
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepend</span>(head, tail) -&gt; <span style="color:#a6e22e">arr</span> <span style="color:#75715e">//...
</span></span></span></code></pre></div><p>Quick code explanation. In the function <code>bubble</code> , we move the least element of <code>arr</code> to the very beginning of the list (i.e. to the head). Then we cut the head off of the arr (since we consider the head sorted) and do the same <code>bubble</code> thing on the tail and again cut the head of that tail off, until the length is 0, and then we construct the whole array by prepending the heads back to their places.</p>
<p>Notice that the implementation is adapted so that it is more convenient for us to express the logic on traits. For example, instead of using <code>swapIfLess</code> it should be written as <code>if (...) swap(...)</code>. Although we could define some traits to define <code>if-else</code> logic, I find it cleaner for now to settle for <code>swapIfLess</code> thing.</p>
<p>Actually, there&rsquo;s a problem with this approach. Look at this line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">return</span> prepend(arr.head, swapIfLess(arr.head, bubble(arr.tail)))
</span></span></code></pre></div><p>The code assumes that <code>arr</code> is passed around by reference, like in javascript for example. For instance, if <code>swapIfLess(arr.head, ...)</code> function mutates <code>arr.head</code> as a result of swapping, the head from <code>prepend(arr.head, ...)</code> is also mutated. We can&rsquo;t mutate anything on the type level, so we need to adapt the implementation for this case.
To solve this, I will define conditional <code>swap</code> and <code>prepend</code> functions as one trait.</p>
<blockquote>
<p>It doesn&rsquo;t mean that there&rsquo;s no other workaround for this problem, if you have a better solution, I would be happy to see it!</p>
</blockquote>
<h2 id="bubble-sort-helper-traits">Bubble sort helper traits<a hidden class="anchor" aria-hidden="true" href="#bubble-sort-helper-traits">#</a></h2>
<p>Let&rsquo;s define that big-arse <code>SwapPrepend</code> trait:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> ComputeSwapPrepend<span style="color:#f92672">&lt;</span>E, H<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Where <code>E</code> is for &ldquo;equality&rdquo; and <code>H</code> is for &ldquo;head&rdquo;. We will define implementations of this trait for different equality types, so for each equality type the computation result will be different (i.e. a decision &ldquo;to swap or not to swap&rdquo; depending on the equality of <code>head</code> and <code>tail[0]</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// For Nil, we just prepend the `Head`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>E: <span style="color:#a6e22e">Equality</span>, Head: <span style="color:#a6e22e">Nat</span><span style="color:#f92672">&gt;</span> ComputeSwapPrepend<span style="color:#f92672">&lt;</span>E, Head<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Nil {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Cons<span style="color:#f92672">&lt;</span>Head, Nil<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// When `Head` and `A` (i.e. &#39;head&#39; and &#39;tail[0]&#39; as in the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pseudo-code example above) are equal, also just prepend the `Head`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Other, Head<span style="color:#f92672">&gt;</span> ComputeSwapPrepend<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">EQ</span>, Head<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Cons<span style="color:#f92672">&lt;</span>A, Other<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Cons<span style="color:#f92672">&lt;</span>Head, Cons<span style="color:#f92672">&lt;</span>A, Other<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// When `Head` &gt; `A`, just prepend
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Other, Head<span style="color:#f92672">&gt;</span> ComputeSwapPrepend<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">GT</span>, Head<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Cons<span style="color:#f92672">&lt;</span>A, Other<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Cons<span style="color:#f92672">&lt;</span>Head, Cons<span style="color:#f92672">&lt;</span>A, Other<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// When `Head` &lt; `A`, we finally swap and prepend.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Other, Head<span style="color:#f92672">&gt;</span> ComputeSwapPrepend<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">GT</span>, Head<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Cons<span style="color:#f92672">&lt;</span>A, Other<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Cons<span style="color:#f92672">&lt;</span>A, Cons<span style="color:#f92672">&lt;</span>Head, Other<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SwapPrepend</span><span style="color:#f92672">&lt;</span>E, H, L<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>L <span style="color:#66d9ef">as</span> ComputeSwapPrepend<span style="color:#f92672">&lt;</span>E, H<span style="color:#f92672">&gt;&gt;</span>::Output;
</span></span></code></pre></div><p>Next, we define one more comparison trait, but this time it will compare <strong>a natural number</strong> with <strong>a list</strong> (i.e. with the list&rsquo;s head). It will help us to compare numbers when we will be implementing a trait for <code>Cons&lt;Head, Tail&gt;</code> where we can&rsquo;t simply get the first element of <code>Tail</code> to compare it with the <code>Head</code> with the old <code>Compare</code> trait, so the new <code>Compare</code> trait will help us with resolving the <code>Tail</code>&rsquo;s first element.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> ComputeCompare<span style="color:#f92672">&lt;</span>Rhs: <span style="color:#a6e22e">Nat</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>: <span style="color:#a6e22e">Equality</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This impl is only used for completeness.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// We will use `Compare` trait in tandem with `SwapPrepend` trait,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and `&lt;Nil as SwapPrepend&lt;T, H&gt;&gt;::Output` thing doesn&#39;t 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// compare anything and only prepends.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// So the `Output` type doesn&#39;t matter in this context.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>Num: <span style="color:#a6e22e">Nat</span><span style="color:#f92672">&gt;</span> ComputeCompare<span style="color:#f92672">&lt;</span>Num<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Nil {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">LT</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Just compare `Head` with `Num`.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `CompareNat` is the old natural number comparison trait.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>Head, Num, Tail<span style="color:#f92672">&gt;</span> ComputeCompare<span style="color:#f92672">&lt;</span>Num<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Cons<span style="color:#f92672">&lt;</span>Head, Tail<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span> Head: <span style="color:#a6e22e">Nat</span> <span style="color:#f92672">+</span> ComputeCompareNat<span style="color:#f92672">&lt;</span>Num<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>          Num: <span style="color:#a6e22e">Nat</span> <span style="color:#f92672">+</span> ComputeCompareNat<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>          Tail: <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> CompareNat<span style="color:#f92672">&lt;</span>Head, Num<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Compare</span><span style="color:#f92672">&lt;</span>N, Ls<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>Ls <span style="color:#66d9ef">as</span> ComputeCompare<span style="color:#f92672">&lt;</span>N<span style="color:#f92672">&gt;&gt;</span>::Output;
</span></span></code></pre></div><p>Above are also some trait bounds for the traits which we should specify to make the situation clear for the compiler.</p>
<p>They are pretty simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Nat {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Nat <span style="color:#66d9ef">for</span> Zero {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>N: <span style="color:#a6e22e">Nat</span><span style="color:#f92672">&gt;</span> Nat <span style="color:#66d9ef">for</span> Succ<span style="color:#f92672">&lt;</span>N<span style="color:#f92672">&gt;</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> List {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> List <span style="color:#66d9ef">for</span> Nil {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>H: <span style="color:#a6e22e">Nat</span>, T: <span style="color:#a6e22e">List</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Cons<span style="color:#f92672">&lt;</span>H, T<span style="color:#f92672">&gt;</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Equality {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Equality <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">EQ</span> {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Equality <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">LT</span> {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Equality <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">GT</span> {}
</span></span></code></pre></div><p>And finally, some little things which will come in handy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">HeadOf</span><span style="color:#f92672">&lt;</span>L<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>L <span style="color:#66d9ef">as</span> ComputeHead<span style="color:#f92672">&gt;</span>::Output;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TailOf</span><span style="color:#f92672">&lt;</span>L<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>L <span style="color:#66d9ef">as</span> ComputeTail<span style="color:#f92672">&gt;</span>::Output;
</span></span></code></pre></div><p>Their functionality is quite simple, try to understand how they are implemented by yourself.</p>
<h2 id="bubbling">Bubbling<a hidden class="anchor" aria-hidden="true" href="#bubbling">#</a></h2>
<p>Now, we are on the key part of the algorithm.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> ComputeBubble {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> ComputeBubble <span style="color:#66d9ef">for</span> Nil {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Nil;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>Head, Tail<span style="color:#f92672">&gt;</span> ComputeBubble <span style="color:#66d9ef">for</span> Cons<span style="color:#f92672">&lt;</span>Head, Tail<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Some big &amp; scary bounds
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">where</span> Head: <span style="color:#a6e22e">Nat</span>,
</span></span><span style="display:flex;"><span>          Tail: <span style="color:#a6e22e">List</span> <span style="color:#f92672">+</span> ComputeBubble <span style="color:#f92672">+</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeBubble<span style="color:#f92672">&gt;</span>::Output: <span style="color:#a6e22e">ComputeSwapPrepend</span><span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;&gt;</span>::Output, Head<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> SwapPrepend<span style="color:#f92672">&lt;</span>Compare<span style="color:#f92672">&lt;</span>Head, Tail<span style="color:#f92672">&gt;</span>, Head, Bubble<span style="color:#f92672">&lt;</span>Tail<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Bubble</span><span style="color:#f92672">&lt;</span>Ls<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>Ls <span style="color:#66d9ef">as</span> ComputeBubble<span style="color:#f92672">&gt;</span>::Output;
</span></span></code></pre></div><p>The <code>Output</code> type computation is not that difficult, try to understand how it does the job by yourself.
You can see that the 3rd trait bound is quite ugly. It just means something like &ldquo;The result of <code>bubbling the Tail</code> must support <code>swap &amp; prepending the Head</code>&rdquo;.</p>
<h2 id="bubble-sorting">Bubble sorting<a hidden class="anchor" aria-hidden="true" href="#bubble-sorting">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> ComputeBubbleSort {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Bubbled</span>: <span style="color:#a6e22e">List</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>: <span style="color:#a6e22e">List</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> ComputeBubbleSort <span style="color:#66d9ef">for</span> Nil {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Bubbled</span> <span style="color:#f92672">=</span> Nil;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Nil;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>Head, Tail<span style="color:#f92672">&gt;</span> ComputeBubbleSort <span style="color:#66d9ef">for</span> Cons<span style="color:#f92672">&lt;</span>Head, Tail<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Oh geez...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">where</span> Head: <span style="color:#a6e22e">Nat</span>,
</span></span><span style="display:flex;"><span>        Tail: <span style="color:#a6e22e">List</span> <span style="color:#f92672">+</span> ComputeBubble <span style="color:#f92672">+</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> ComputePrepend<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> ComputeBubbleSort,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeBubble<span style="color:#f92672">&gt;</span>::Output: <span style="color:#a6e22e">ComputeSwapPrepend</span><span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;&gt;</span>::Output, Head<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeBubble<span style="color:#f92672">&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeSwapPrepend<span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;&gt;</span>::Output, Head<span style="color:#f92672">&gt;&gt;</span>::Output: <span style="color:#a6e22e">ComputeHead</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeBubble<span style="color:#f92672">&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeSwapPrepend<span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;&gt;</span>::Output, Head<span style="color:#f92672">&gt;&gt;</span>::Output: <span style="color:#a6e22e">ComputeTail</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeBubble<span style="color:#f92672">&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeSwapPrepend<span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;&gt;</span>::Output, Head<span style="color:#f92672">&gt;&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeTail<span style="color:#f92672">&gt;</span>::Output: <span style="color:#a6e22e">ComputeBubbleSort</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&lt;&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeBubble<span style="color:#f92672">&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeSwapPrepend<span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;&gt;</span>::Output, Head<span style="color:#f92672">&gt;&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeTail<span style="color:#f92672">&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeBubbleSort<span style="color:#f92672">&gt;</span>::Output: <span style="color:#a6e22e">ComputePrepend</span><span style="color:#f92672">&lt;&lt;&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeBubble<span style="color:#f92672">&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeSwapPrepend<span style="color:#f92672">&lt;&lt;</span>Tail <span style="color:#66d9ef">as</span> ComputeCompare<span style="color:#f92672">&lt;</span>Head<span style="color:#f92672">&gt;&gt;</span>::Output, Head<span style="color:#f92672">&gt;&gt;</span>::Output <span style="color:#66d9ef">as</span> ComputeHead<span style="color:#f92672">&gt;</span>::Output<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Bubbled</span> <span style="color:#f92672">=</span> Bubble<span style="color:#f92672">&lt;</span>Cons<span style="color:#f92672">&lt;</span>Head, Tail<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Prepend<span style="color:#f92672">&lt;</span>HeadOf<span style="color:#f92672">&lt;</span>Self::Bubbled<span style="color:#f92672">&gt;</span>, BubbleSort<span style="color:#f92672">&lt;</span>TailOf<span style="color:#f92672">&lt;</span>Self::Bubbled<span style="color:#f92672">&gt;&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BubbleSort</span><span style="color:#f92672">&lt;</span>Ls<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>Ls <span style="color:#66d9ef">as</span> ComputeBubbleSort<span style="color:#f92672">&gt;</span>::Output;
</span></span></code></pre></div><p>Again, the <code>Output</code> type is not what scares, but the trait bounds. Actually, I didn&rsquo;t write them by myself, these bounds where suggested by compiler. We can think of them as just a thing to make the compiler satisfied about the types. You can run <code>rustfmt</code> on the code to prettify it if you want to dig into what, for example, the last bound is for, but it can be briefly described as &ldquo;the result of computing trait A must implement trait B&rdquo;, but following the whole chain of trait invocations.</p>
<p>As I know, there isn&rsquo;t a way to specify an implied trait bound (that is, we know that the result of <code>BubbleSort&lt;TailOf&lt;Bubble&lt;Cons&lt;..&gt;&gt;&gt;&gt;</code> is a <code>List</code>, but for the compiler to be satisfied we must write the whole chain of invocations like <code>&lt;&lt;Cons&lt;..&gt; as Bubble&gt;::Output as TailOf&gt;::Output as BubbleSort and etc</code> in the trait bounds) in current version of Rust, but there&rsquo;s <a href="https://rust-lang.github.io/rfcs/2089-implied-bounds.html">an RFC</a> for this thing which is not implemented yet.</p>
<h2 id="testing">Testing<a hidden class="anchor" aria-hidden="true" href="#testing">#</a></h2>
<p><img loading="lazy" src="/4aoi43ihq8hmoymm7oys.png" alt="Bubble sort testing"  />
</p>
<p>The computed natural number types were expanded, but you can see that the list became sorted (the <code>N1</code>, <code>N2</code> types are just aliases for <code>Succ&lt;Zero&gt;</code> and <code>Succ&lt;Succ&lt;Zero&gt;&gt;</code>).</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>The implementation is far from being perfect, but at least it works. There are ugly trait bounds which are completely unreadable, and I don&rsquo;t know any way to simplify them. But it&rsquo;s enough to show what the Rust&rsquo;s type system is capable of.
It is not worth to say that this variation of algorithm is not practically useful. But it is a good way to challenge your mind and try something extraordinary!</p>
<p>The full source code:</p>
<blockquote>
<p><a href="https://github.com/thedenisnikulin/type-level-sort">https://github.com/thedenisnikulin/type-level-sort</a></p>
</blockquote>
<h2 id="links">Links<a hidden class="anchor" aria-hidden="true" href="#links">#</a></h2>
<p><a href="https://willcrichton.net/notes/type-level-programming/">A much more practically useful type-level programming in Rust</a> <br>
<a href="https://github.com/willcrichton/tyrade">A macro to define type-level logic with value-level syntax in Rust</a> <br>
<a href="https://sdleffler.github.io/RustTypeSystemTuringComplete/">Type-level Brainfuck in Rust</a> <br>
<a href="https://beachape.com/blog/2017/03/12/gentle-intro-to-type-level-recursion-in-Rust-from-zero-to-frunk-hlist-sculpting/">&ldquo;Gentle Intro to Type-level Recursion in Rust&rdquo; </a> <br>
<a href="https://blog.auxon.io/2019/10/25/type-level-registers/">Type-level registers in Rust</a> <br>
<a href="https://blog.rockthejvm.com/type-level-quicksort/">Type-level quicksort in Scala&quot;</a> <br>
<a href="https://gist.github.com/pxqr/3754181">Type-level sorting algorithms in Haskell</a> <br>
<a href="https://github.com/ronami/meta-typing">A repo with functions and algorithms implemented purely on types in TypeScript</a> \</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">tinyblog</a></span> 繚 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
